{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@orrisroot/inject-loader/./src/index.ts","webpack://@orrisroot/inject-loader/./src/injectify.ts","webpack://@orrisroot/inject-loader/./src/wrapper_template.ts","webpack://@orrisroot/inject-loader/./src/wrapper_template_esm.ts","webpack://@orrisroot/inject-loader/external commonjs \"@babel/core\"","webpack://@orrisroot/inject-loader/webpack/bootstrap","webpack://@orrisroot/inject-loader/webpack/startup"],"sourcesContent":["import type { LoaderContext } from 'webpack';\n\nimport injectify from './injectify';\nimport type { InputSourceMap } from './types';\n\nfunction loader(this: LoaderContext<object>, content: string, sourceMap?: InputSourceMap) {\n  if (this.cacheable) {\n    this.cacheable();\n  }\n\n  const { code, map } = injectify(this, content, sourceMap)!;\n  this.callback(null, code as string, map as InputSourceMap);\n}\n\nexport default loader;\n","import type { NodePath } from '@babel/core';\nimport { types as t, transformFromAstSync, transformSync, traverse } from '@babel/core';\nimport type { LoaderContext } from 'webpack';\n\nimport type { InputSourceMap } from './types';\nimport wrapperTemplate from './wrapper_template';\nimport wrapperTemplateESM from './wrapper_template_esm';\n\nconst processRequireCall = (path: NodePath<t.CallExpression>) => {\n  t.assertStringLiteral(path.node.arguments[0]);\n  const dependencyString = path.node.arguments[0].value;\n  path.replaceWith(\n    t.expressionStatement(\n      t.conditionalExpression(\n        t.callExpression(\n          t.memberExpression(t.identifier('__injections'), t.identifier('hasOwnProperty'), false),\n          [t.stringLiteral(dependencyString)]\n        ),\n        t.memberExpression(t.identifier('__injections'), t.stringLiteral(dependencyString), true),\n        path.node\n      )\n    )\n  );\n\n  return dependencyString;\n};\n\nconst processImport = (path: NodePath<t.ImportDeclaration>) => {\n  const { node } = path;\n  const dependencyString = node.source.value;\n\n  const injectionStatements: t.VariableDeclaration[] = [];\n  const aliasedSpecifiers = node.specifiers.map((specifier) => {\n    const localIdentifier = specifier.local;\n    // ex: __React\n    const aliasIdentifier = t.identifier(`__${localIdentifier.name}`);\n    // __injections['react']\n    let injectionExpression = t.memberExpression(\n      t.identifier('__injections'),\n      t.stringLiteral(dependencyString),\n      true\n    );\n    if (t.isImportSpecifier(specifier)) {\n      // __injections['react'].Component\n      injectionExpression = t.memberExpression(injectionExpression, specifier.imported);\n    }\n\n    injectionStatements.push(\n      t.variableDeclaration('var', [\n        t.variableDeclarator(\n          localIdentifier,\n          t.conditionalExpression(\n            t.callExpression(\n              t.memberExpression(\n                t.identifier('__injections'),\n                t.identifier('hasOwnProperty'),\n                false\n              ),\n              [t.stringLiteral(dependencyString)]\n            ),\n            injectionExpression,\n            aliasIdentifier\n          )\n        ),\n      ])\n    );\n\n    specifier.local = aliasIdentifier;\n    return specifier;\n  });\n\n  const aliasedImport = t.importDeclaration(aliasedSpecifiers, node.source);\n\n  path.replaceWithMultiple(injectionStatements);\n\n  return {\n    node: aliasedImport,\n    dependencyString,\n  };\n};\n\nconst processDynamicImport = (path: NodePath<t.CallExpression>) => {\n  t.assertStringLiteral(path.node.arguments[0]);\n  const dependencyString = path.node.arguments[0].value;\n  path.replaceWith(\n    t.expressionStatement(\n      t.conditionalExpression(\n        t.callExpression(\n          t.memberExpression(t.identifier('__injections'), t.identifier('hasOwnProperty'), false),\n          [t.stringLiteral(dependencyString)]\n        ),\n        t.callExpression(\n          t.memberExpression(t.identifier('Promise'), t.identifier('resolve'), false),\n          [\n            t.memberExpression(\n              t.identifier('__injections'),\n              t.stringLiteral(dependencyString),\n              true\n            ),\n          ]\n        ),\n        path.node\n      )\n    )\n  );\n\n  return dependencyString;\n};\n\n// module.exports[exportIdentifier] = localIdentifier\nconst createExportAssignment = (\n  exportIdentifier: t.PrivateName | t.Expression,\n  localIdentifier: t.Expression\n) =>\n  t.expressionStatement(\n    t.assignmentExpression(\n      '=',\n      t.memberExpression(\n        t.memberExpression(t.identifier('module'), t.identifier('exports'), false),\n        exportIdentifier,\n        false\n      ),\n      localIdentifier\n    )\n  );\n\nconst processDefaultExport = (path: NodePath<t.ExportDefaultDeclaration>) => {\n  let exportAssignment: t.ExpressionStatement | null = null;\n  const { declaration } = path.node;\n\n  if (t.isFunctionDeclaration(declaration)) {\n    exportAssignment = createExportAssignment(\n      t.identifier('default'),\n      t.functionExpression(\n        declaration.id,\n        declaration.params,\n        declaration.body,\n        declaration.generator,\n        declaration.async\n      )\n    );\n  } else if (t.isExpression(path.node.declaration)) {\n    exportAssignment = createExportAssignment(t.identifier('default'), path.node.declaration);\n  }\n\n  if (exportAssignment != null) {\n    path.replaceWith(exportAssignment);\n  }\n};\n\nconst processNamedExport = (path: NodePath<t.ExportNamedDeclaration>) => {\n  let statements: t.Statement[] = [];\n\n  const { declaration } = path.node;\n  if (declaration) {\n    statements.push(declaration);\n    if (t.isVariableDeclaration(declaration)) {\n      declaration.declarations.forEach((d) => {\n        t.assertExpression(d.id);\n        statements.push(\n          createExportAssignment(d.id, d.init && t.isLiteral(d.init) ? d.init : d.id)\n        );\n      });\n    } else if (\n      (t.isClassDeclaration(declaration) || t.isFunctionDeclaration(declaration)) &&\n      declaration.id != null\n    ) {\n      statements.push(createExportAssignment(declaration.id, declaration.id));\n    }\n  } else {\n    statements = path.node.specifiers\n      .filter((specifier): specifier is t.ExportSpecifier => t.isExportSpecifier(specifier))\n      .map((specifier) => createExportAssignment(specifier.exported, specifier.local));\n  }\n\n  path.replaceWithMultiple(statements);\n};\n\nconst injectify = (\n  context: LoaderContext<object>,\n  source: string,\n  inputSourceMap?: InputSourceMap\n) => {\n  const { ast } = transformSync(source, {\n    ast: true,\n    code: false,\n    babelrc: false,\n    compact: false,\n    configFile: false,\n    filename: context.resourcePath,\n  })!;\n  t.assertFile(ast);\n\n  const dependencies: string[] = [];\n  const imports: t.Statement[] = [];\n  let usesESModules = false;\n\n  traverse(ast, {\n    CallExpression(path) {\n      if (t.isIdentifier(path.node.callee, { name: 'require' })) {\n        dependencies.push(processRequireCall(path));\n        path.skip();\n      } else if (t.isImport(path.node.callee)) {\n        dependencies.push(processDynamicImport(path));\n        path.skip();\n      }\n    },\n    ImportDeclaration(path) {\n      usesESModules = true;\n      const { node, dependencyString } = processImport(path);\n      imports.push(node);\n      dependencies.push(dependencyString);\n      path.skip();\n    },\n    ExportDefaultDeclaration(path) {\n      usesESModules = true;\n      processDefaultExport(path);\n      path.skip();\n    },\n    ExportNamedDeclaration(path) {\n      usesESModules = true;\n      processNamedExport(path);\n      path.skip();\n    },\n  });\n\n  if (dependencies.length === 0) {\n    context.emitWarning(\n      new Error(\n        \"The module you are trying to inject into doesn't have any dependencies. \" +\n          'Are you sure you want to do this?'\n      )\n    );\n  }\n  const template = usesESModules ? wrapperTemplateESM : wrapperTemplate;\n\n  const wrapperModuleAst = t.file(\n    t.program([\n      ...imports,\n      template({\n        SOURCE: ast.program.body,\n        SOURCE_PATH: t.stringLiteral(context.resourcePath),\n        DEPENDENCIES: t.arrayExpression(dependencies.map((d) => t.stringLiteral(d))),\n      }) as t.Statement,\n    ])\n  );\n\n  return transformFromAstSync(wrapperModuleAst, source, {\n    sourceMaps: context.sourceMap,\n    sourceFileName: context.resourcePath,\n    inputSourceMap: inputSourceMap || undefined,\n    babelrc: false,\n    compact: false,\n    configFile: false,\n    filename: context.resourcePath,\n  });\n};\n\nexport default injectify;\n","import { template } from '@babel/core';\n\nexport default template(`\n  module.exports = function __injector(__injections) {\n    __injections = __injections || {};\n\n    (function __validateInjection() {\n      var validDependencies = DEPENDENCIES;\n      var injectedDependencies = Object.keys(__injections);\n      var invalidInjectedDependencies = injectedDependencies.filter(function (dependency) {\n        return validDependencies.indexOf(dependency) === -1;\n      });\n\n      if (invalidInjectedDependencies.length > 0) {\n        var validDependenciesString = ' - ' + validDependencies.join('\\\\n - ');\n        var injectedDependenciesString = ' - ' + injectedDependencies.join('\\\\n - ');\n        var invalidDependenciesString = ' - ' + invalidInjectedDependencies.join('\\\\n - ');\n\n        throw new Error('Injection Error in ' + SOURCE_PATH + '\\\\n\\\\n' +\n          'The following injections are invalid:\\\\n' + invalidDependenciesString + '\\\\n\\\\n' +\n          'The following injections were passed in:\\\\n' + injectedDependenciesString + '\\\\n\\\\n' +\n          'Valid injection targets for this module are:\\\\n' + validDependenciesString + '\\\\n'\n        );\n      }\n    })();\n\n    __injector.sourcePath = SOURCE_PATH;\n    __injector.validDependencies = DEPENDENCIES;\n\n    var module = { exports: {} };\n    var exports = module.exports;\n\n    (function () {\n      SOURCE\n    })();\n\n    return module.exports;\n  }\n`);\n","import { template } from '@babel/core';\n\nexport default template(\n  `\n  export default function __injector(__injections) {\n    __injections = __injections || {};\n\n    (function __validateInjection() {\n      var validDependencies = DEPENDENCIES;\n      var injectedDependencies = Object.keys(__injections);\n      var invalidInjectedDependencies = injectedDependencies.filter(function (dependency) {\n        return validDependencies.indexOf(dependency) === -1;\n      });\n\n      if (invalidInjectedDependencies.length > 0) {\n        var validDependenciesString = ' - ' + validDependencies.join('\\\\n - ');\n        var injectedDependenciesString = ' - ' + injectedDependencies.join('\\\\n - ');\n        var invalidDependenciesString = ' - ' + invalidInjectedDependencies.join('\\\\n - ');\n\n        throw new Error('Injection Error in ' + SOURCE_PATH + '\\\\n\\\\n' +\n          'The following injections are invalid:\\\\n' + invalidDependenciesString + '\\\\n\\\\n' +\n          'The following injections were passed in:\\\\n' + injectedDependenciesString + '\\\\n\\\\n' +\n          'Valid injection targets for this module are:\\\\n' + validDependenciesString + '\\\\n'\n        );\n      }\n    })();\n\n    __injector.sourcePath = SOURCE_PATH;\n    __injector.validDependencies = DEPENDENCIES;\n\n    var module = { exports: {} };\n    var exports = module.exports;\n\n    (function () {\n      SOURCE\n    })();\n\n    if (module.exports.hasOwnProperty('default') && Object.keys(module.exports).length === 1) {\n      module.exports = module.exports.default;\n    }\n\n    return module.exports;\n}\n`,\n  { sourceType: 'module' }\n);\n","module.exports = require(\"@babel/core\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["content","sourceMap","this","cacheable","code","map","callback","createExportAssignment","exportIdentifier","localIdentifier","expressionStatement","assignmentExpression","memberExpression","identifier","context","source","inputSourceMap","ast","transformSync","babelrc","compact","configFile","filename","resourcePath","assertFile","dependencies","imports","usesESModules","traverse","CallExpression","path","isIdentifier","node","callee","name","push","assertStringLiteral","arguments","dependencyString","value","replaceWith","conditionalExpression","callExpression","stringLiteral","processRequireCall","skip","isImport","processDynamicImport","ImportDeclaration","injectionStatements","aliasedSpecifiers","specifiers","specifier","local","aliasIdentifier","injectionExpression","isImportSpecifier","imported","variableDeclaration","variableDeclarator","aliasedImport","importDeclaration","replaceWithMultiple","processImport","ExportDefaultDeclaration","exportAssignment","declaration","isFunctionDeclaration","functionExpression","id","params","body","generator","async","isExpression","processDefaultExport","ExportNamedDeclaration","statements","isVariableDeclaration","declarations","forEach","d","assertExpression","init","isLiteral","isClassDeclaration","filter","isExportSpecifier","exported","processNamedExport","length","emitWarning","Error","template","wrapperModuleAst","file","program","SOURCE","SOURCE_PATH","DEPENDENCIES","arrayExpression","transformFromAstSync","sourceMaps","sourceFileName","undefined","sourceType","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}